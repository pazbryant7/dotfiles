#!/bin/sh

OUTPUT_DIR="$HOME/Videos/recordings"
readonly OUTPUT_DIR

FILENAME_PREFIX="recording"
readonly FILENAME_PREFIX

PID_FILE="/tmp/screen_recorder.pid"
readonly PID_FILE

LOG_FILE="/tmp/screen_recorder.log"
readonly LOG_FILE

PREDEFINED_MONITOR=":0.0+0,0"
readonly PREDEFINED_MONITOR

FFMPEG_INPUT_OPTS=""
FFMPEG_PROFILE_OPTS=""

refresh_status_bar() {
	pkill -RTMIN+1 slstatus
}

select_profile() {
	profile=$(printf "4k_b - VP9 codec, balanced\n4k_q - H.264 codec, high quality\nfhd_q - Full HD, high quality\n4k_f - 4K, faster encoding\nfhd_f - Full HD, faster encoding" |
		rofi -dmenu -p "Select recording profile")

	if [ -z "$profile" ]; then
		return 1
	fi

	profile_name=$(printf '%s' "$profile" | awk '{print $1}')
	printf '%s' "$profile_name"
	return 0
}

set_recording_parameters() {
	profile_alias="$1"
	input_source="$2"

	case "$profile_alias" in
	4k_b) FFMPEG_PROFILE_OPTS="-c:v libvpx-vp9 -crf 24 -b:v 0 -cpu-used 2 -an -s 3840x2160" ;;
	4k_q) FFMPEG_PROFILE_OPTS="-c:v libx264 -preset slow -crf 18 -g 15 -bf 2 -pix_fmt yuv420p -movflags +faststart -an -s 3840x2160" ;;
	fhd_q) FFMPEG_PROFILE_OPTS="-c:v libx264 -preset slow -crf 18 -g 15 -bf 2 -pix_fmt yuv420p -movflags +faststart -an -s 1920x1080" ;;
	4k_f) FFMPEG_PROFILE_OPTS="-c:v libx264 -preset faster -crf 22 -g 30 -bf 2 -pix_fmt yuv420p -movflags +faststart -an -s 3840x2160" ;;
	fhd_f) FFMPEG_PROFILE_OPTS="-c:v libx264 -preset faster -crf 20 -g 30 -bf 2 -pix_fmt yuv420p -movflags +faststart -an -s 1920x1080" ;;
	*)
		echo "Error: Profile '$profile_alias' not found."
		return 1
		;;
	esac

	FFMPEG_INPUT_OPTS="-f x11grab -draw_mouse 1 -i ${input_source}"
	return 0
}

start_recording() {
	profile_alias="$1"
	timestamp=$(date '+%Y-%m-%d_%H-%M-%S')
	output_file="${OUTPUT_DIR}/${FILENAME_PREFIX}_${timestamp}.mkv"

	printf "Starting recording with profile: %s\n" "$profile_alias"
	printf "Output file: %s\n" "$output_file"

	sh -c "ffmpeg $FFMPEG_INPUT_OPTS $FFMPEG_PROFILE_OPTS \"$output_file\" > \"$LOG_FILE\" 2>&1 & echo \$! > \"$PID_FILE\""

	sleep 1

	recorded_pid=""
	if [ -f "$PID_FILE" ]; then
		recorded_pid=$(cat "$PID_FILE")
	fi

	if [ -n "$recorded_pid" ] && ps -p "$recorded_pid" >/dev/null; then
		refresh_status_bar
		printf "Recording started. PID: %s\n" "$recorded_pid"
		return 0
	fi

	printf "Error: Failed to start ffmpeg. Check %s for details.\n" "$LOG_FILE" >&2
	rm -f "$PID_FILE"
	return 1
}

is_recording() {
	if [ ! -f "$PID_FILE" ]; then
		return 1
	fi

	pid=$(cat "$PID_FILE")

	if [ -z "$pid" ] || ! ps -p "$pid" >/dev/null 2>&1; then
		return 1
	fi

	return 0
}

stop_recording() {
	if ! is_recording; then
		echo "Not recording (no PID file found)."
		return 1
	fi

	pid=$(cat "$PID_FILE")
	printf "Stopping recording (PID: %s)...\n" "$pid"
	kill -INT "$pid"

	count=0
	while ps -p "$pid" >/dev/null 2>&1; do
		sleep 1
		count=$((count + 1))
		if [ "$count" -gt 10 ]; then
			printf "ffmpeg (PID: %s) did not stop gracefully after 10s. Sending SIGKILL.\n" "$pid" >&2
			kill -KILL "$pid"
			break
		fi
	done

	rm -f "$PID_FILE"
	refresh_status_bar
	printf "Recording stopped.\n"
	return 0
}

cleanup_stale_pid() {
	if [ ! -f "$PID_FILE" ]; then
		return
	fi

	pid=$(cat "$PID_FILE")

	if [ -n "$pid" ] || ! ps -p "$pid" >/dev/null 2>&1; then
		printf "Stale PID file found. Cleaning up.\n"
		rm -f "$PID_FILE"
	fi
}

main() {
	if ! mkdir -p "$OUTPUT_DIR"; then
		printf "Error: Could not create output directory %s\n" "$OUTPUT_DIR" >&2
		exit 1
	fi

	if is_recording; then
		stop_recording
	else
		cleanup_stale_pid

		profile=$(select_profile) || exit 1

		if set_recording_parameters "$profile" "$PREDEFINED_MONITOR"; then
			if ! start_recording "$profile"; then
				exit 1
			fi
		else
			exit 1
		fi
	fi

	exit 0
}

main "$@"
